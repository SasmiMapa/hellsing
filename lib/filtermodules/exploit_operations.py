import os
import re
import subprocess
import textwrap

from lib.core.Config import RESULTS_DIR
from lib.output.Logger import logger  
from lib.output import Output
from lib.utils.StringUtils import StringUtils

class ExploitOperations:
    def __init__(self):
        pass
    
    #-----------------------------------------------------------------------
    
    def please_exploit_tool(self, command, tool_name, check_name):
        try:
            if check_name == "hydra-http-post-form-brute":
                # Initialize variables to ensure they are defined
                request_header = username_field = password_field = response_string = databases = None
                  
                # Check if hydra_post_form_inputs.txt exists
                hydra_inputs_path = os.path.join(RESULTS_DIR, "hydra_post_form_inputs.txt")
                
                if not os.path.exists(hydra_inputs_path):
                    with open(hydra_inputs_path, "w") as file:
                        # create the file if it does not exist
                        file.write("") 
                        
                logger.info("Information:")
                x = Output.colored("[1] Request header ", color="148", attrs="bold")
                x2 = Output.colored(": Request header of the login page. (e.g., Login.asp)") 
                y = Output.colored("[2] Parameters     ", color="148", attrs="bold")
                y2 = Output.colored(": Parameters of the login page. (e.g., username, password)")
                z = Output.colored("[3] Response string", color="148", attrs="bold")
                z2 = Output.colored(": Response string for failed login. (e.g., F=Invalid login!)")
                
                print(x + x2)
                print(y + y2)
                print(z + z2)
                print("")
                
                logger.info("Procedure:")
                x= Output.colored("If it's the first time running this module for a particular target, you have to first open the Burpsuite to get the required information and save it somewhere that you can access later. And then you can input the required information when prompted. If you have already run this module for the target, you can input 'n' when it is prompted to use the previous inputs that's saved upon the first run.")
                wrapped_text = textwrap.wrap(x, width=120) 
                Output.print("\n".join(wrapped_text))
                print("")
                   
                logger.info("Instructions:")
                Output.print("[1] Input 'y' to open the burp suite and get the request header and the parameters.", color="141", attrs="bold")
                Output.print("[2] Input 'n' if you already have the request header and the parameters.", color="141", attrs="bold")
                Output.print("[3] Input the request header, parameters, and the response string when prompted.", color="141", attrs="bold")
                Output.print("[4] Execute the module.", color="141", attrs="bold")
  
                print("")
                
                previous_inputs_choices = "n"
                with open(hydra_inputs_path, "r") as file:
                            lines = file.readlines()
                
                if os.path.exists(hydra_inputs_path) and len(lines) > 0:
                        # # First, display the previous inputs
                        # with open(hydra_inputs_path, "r") as file:
                        #     lines = file.readlines()
                        request_header_display = lines[0].strip().split(" ", 1)[1]
                        username_field_display = lines[1].strip().split(" ", 1)[1]
                        password_field_display = lines[2].strip().split(" ", 1)[1]
                        response_string_display = lines[3].strip().split(" ", 1)[1]
                        
                        Output.print(f"+------------------------+", color="blue", attrs="bold")
                        Output.print(f"[*] Previous inputs found:", color="blue", attrs="bold")
                        Output.print(f"+------------------------+", color="blue", attrs="bold")
                        logger.success(f"Request header       : {request_header_display}")
                        logger.success(f"Username             : {username_field_display}")
                        logger.success(f"Password             : {password_field_display}")
                        logger.success(f"Response string      : {response_string_display}")
                        Output.print(f"+------------------------+", color="blue", attrs="bold")
                        print("")

                        previous_inputs_choices = input(f"\033[1m[>] Would you like to import the previous inputs? (Y/n): \033[0m")
                          
                if previous_inputs_choices.lower() == 'y':
                    print("")
                    
                    request_header = request_header_display
                    username_field = username_field_display
                    password_field = password_field_display
                    response_string = response_string_display

                else:
                    print("")
                    logger.warning("Previous inputs not found or inputs not provided.")
                    burpsuite_decision = input(f"\033[1m[>] Would you like to launch Burpsuite to get the request string? (Y/n): \033[0m")
                    
                    if burpsuite_decision.lower() == 'y':
                        subprocess.run(["burpsuite"])
                        
                    print("")
                            
                # Prompt for inputs if not importing or no previous inputs
                if not request_header:
                    request_header = input("\033[1m[>] Enter the request header (e.g., Login.asp?): \033[0m")
                    username_field = input("\033[1m[>] Enter the user name field (e.g., username): \033[0m")
                    password_field = input("\033[1m[>] Enter the password field (e.g., password): \033[0m")
                    response_string = input("\033[1m[>] Enter the response string for fail logins (e.g., F=Invalid login!): \033[0m")
                    print("")

                    # Save inputs for future use
                    with open(hydra_inputs_path, "w") as file:
                        file.write(f"[REQUEST_HEADER] {request_header}\n")
                        file.write(f"[USERNAME_FIELD] {username_field}\n")
                        file.write(f"[PASSWORD_FIELD] {password_field}\n")
                        file.write(f"[RESPONSE_STRING] {response_string}\n")
     
                # Ensure variables are defined before replacing in command
                if request_header and username_field and password_field and response_string:
                    if "[REQUEST_HEADER]" in command:
                        command = command.replace("[REQUEST_HEADER]", request_header)
                    if "[USERNAME_FIELD]" in command:
                        command = command.replace("[USERNAME_FIELD]", username_field)
                    if "[PASSWORD_FIELD]" in command:
                        command = command.replace("[PASSWORD_FIELD]", password_field)
                    if "[RESPONSE_STRING]" in command:
                        command = command.replace("[RESPONSE_STRING]", response_string)
                        
            elif check_name == "sqlmap-sql-db-scan":
                self.sqlmap_default()
                                      
            elif check_name == "sqlmap-sql-table-dump":
                if "[DATABASES]" in command:
                    databases = input("\033[1m[>] Enter the database name to dump (e.g., db2): \033[0m")
                    print("")
                    command = command.replace("[DATABASES]", databases)
                
                self.sqlmap_default()
                
            elif check_name == "sqlmap-sql-column-dump":
                if "[DATABASES]" in command:
                    databases = input("\033[1m[>] Enter the database name to dump (e.g., db2): \033[0m")
                    command = command.replace("[DATABASES]", databases)
                
                if "[TABLES]" in command:
                    tables = input("\033[1m[>] Enter the table name to dump (e.g., users): \033[0m")
                    print("")
                    command = command.replace("[TABLES]", tables)
                    
                self.sqlmap_default()
                
        except Exception as e:
            logger.error(f"Error: {e}")
            
        finally:
            return command
    #-----------------------------------------------------------------------
    
    def burp_suite_open(self, sqlmap_request_file):
        subprocess.run(["burpsuite"])
    
        if os.path.exists(sqlmap_request_file):  
            with open(sqlmap_request_file, "r") as file:
                sql_request = file.read()
                
            if sql_request:
                sql_request = sql_request
        return sql_request
                
    #-----------------------------------------------------------------------
    
    def sqlmap_default(self):
        """
        Run the default SQLMap command.
        """
        sql_request = None
        
        # Check if sqlmap_request.txt exists
        sqlmap_request_file = os.path.join(RESULTS_DIR, "sqlmap-sql-injection-request.txt")
        
        if not os.path.exists(sqlmap_request_file):
            with open(sqlmap_request_file, "w") as file:
                # create the file if it does not exist
                file.write("")
        
        burpsuite_decision = input(f"\033[1m[>] Would you like to launch Burpsuite to get the request? (Y/n): \033[0m")
        if burpsuite_decision.lower() == 'y':
            sql_request = self.burp_suite_open(sqlmap_request_file)
            print("")
            
        else:
            print("")
            import_decision = "n"
            
            if os.path.exists(sqlmap_request_file):
                # First, display the previous request
                with open(sqlmap_request_file, "r") as file:
                    sql_request = file.read()
                
                if sql_request:
                    Output.print(f"+------------------------+", color="blue", attrs="bold")
                    Output.print(f"[*] Previous request found:", color="blue", attrs="bold")
                    Output.print(f"+------------------------+", color="blue", attrs="bold")
                    Output.print(f"{sql_request}", color="green")
                    Output.print(f"+------------------------+", color="blue", attrs="bold")
                    print("")
                    
                    # Then ask if the user wants to import it
                    import_decision = input(f"\033[1m[>] Would you like to import the previous request? (Y/n): \033[0m")
                    print("")
                    if import_decision.lower() == 'y':
                        import_decision = 'y'
                        sql_request = sql_request  
            
        # Prompt for inputs if not importing or no previous inputs
        if not sql_request and import_decision.lower() == 'n':
            logger.info("Request for the SQL injection not found.")
            logger.error("Please provide the request for the SQL injection.")    
            
            burpsuite_decision = input(f"\033[1m[>] Launch Burpsuite to get the request or import from the request file? (Y/n): \033[0m")
            print("")
            
            if burpsuite_decision.lower() == 'y':
                self.burp_suite_open(sqlmap_request_file)
            else:
                if os.path.exists(sqlmap_request_file):
                    # First, display the previous request
                    with open(sqlmap_request_file, "r") as file:
                        sql_request = file.read()
                        
                    if sql_request:
                        logger.info("Request will be imported from the request file.")
                        print("")
                        return None
                    else:
                        logger.error("Request file is empty.")