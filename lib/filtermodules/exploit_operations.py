import os
import re
import subprocess

from lib.core.Config import RESULTS_DIR
from lib.output.Logger import logger  
from lib.output import Output
from lib.utils.StringUtils import StringUtils

class ExploitOperations:
    def __init__(self):
        pass
    
    #-----------------------------------------------------------------------
    
    def please_exploit_tool(self, command, tool_name, check_name):
        try:
            if check_name == "hydra-http-post-form-brute":
                # Initialize variables to ensure they are defined
                request_header = username_field = password_field = response_string = databases = None
                  
                # Check if hydra_post_form_inputs.txt exists
                hydra_inputs_path = os.path.join(RESULTS_DIR, "hydra_post_form_inputs.txt")
                
                if not os.path.exists(hydra_inputs_path):
                    with open(hydra_inputs_path, "w") as file:
                        # create the file if it does not exist
                        file.write("") 
                        
                logger.info("Information:")
                Output.print("[~] This hydra module requires 3 strings to be provided.")
                Output.print("[1] Request header : Request header of the login page. (e.g., Login.asp)")
                Output.print("[2] Parameters     : Parameters of the login page. (e.g., username, password)")
                Output.print("[3] Response string: Response string for failed login. (e.g., F=Invalid login!)")
                print("")
                
                logger.info("Procedure:")
                Output.print("[~] To ")
                   
                logger.info("Instructions: Follow the below steps to get the required information.")
                Output.print("1. Input 'n' if you already have the request header and the parameters required for the hydra command or they ")
                Output.print("1. Input 'y' to open the burp suite and get the request header and the parameters which are required for the hydra command.")
                Output.print("2. ")
            

                burpsuite_decision = input(f"\033[1m[>] Would you like to launch Burpsuite to get the request string? (Y/n): \033[0m")
                          
                if burpsuite_decision.lower() == 'y':
                    subprocess.run(["burpsuite"])
                    print("")
                else:
                    print("")
                    
                    with open(hydra_inputs_path, "r") as file:
                            lines = file.readlines()
                
                    if os.path.exists(hydra_inputs_path) and len(lines) > 0:
                        # # First, display the previous inputs
                        # with open(hydra_inputs_path, "r") as file:
                        #     lines = file.readlines()
                        request_header_display = lines[0].strip().split(" ", 1)[1]
                        username_field_display = lines[1].strip().split(" ", 1)[1]
                        password_field_display = lines[2].strip().split(" ", 1)[1]
                        response_string_display = lines[3].strip().split(" ", 1)[1]
                    
                        print("")
                        Output.print(f"+------------------------+", color="blue", attrs="bold")
                        Output.print(f"[*] Previous inputs found:", color="blue", attrs="bold")
                        Output.print(f"+------------------------+", color="blue", attrs="bold")
                        logger.success(f"Request header       : {request_header_display}")
                        logger.success(f"Username             : {username_field_display}")
                        logger.success(f"Password             : {password_field_display}")
                        logger.success(f"Response string      : {response_string_display}")
                        Output.print(f"+------------------------+", color="blue", attrs="bold")
                        print("")
                        
                        # Then ask if the user wants to import them
                        import_decision = input(f"\033[1m[>] Would you like to import the previous inputs? (Y/n): \033[0m")
                        print("")
                        if import_decision.lower() == 'y':
                            request_header = request_header_display
                            username_field = username_field_display
                            password_field = password_field_display
                            response_string = response_string_display
                            
                # Prompt for inputs if not importing or no previous inputs
                if not request_header:
                    request_header = input("\033[1m[>] Enter the request header (e.g., Login.asp?): \033[0m")
                    username_field = input("\033[1m[>] Enter the user name field (e.g., username): \033[0m")
                    password_field = input("\033[1m[>] Enter the password field (e.g., password): \033[0m")
                    response_string = input("\033[1m[>] Enter the response string for fail logins (e.g., F=Invalid login!): \033[0m")
                    print("")

                    # Save inputs for future use
                    with open(hydra_inputs_path, "w") as file:
                        file.write(f"[REQUEST_HEADER] {request_header}\n")
                        file.write(f"[USERNAME_FIELD] {username_field}\n")
                        file.write(f"[PASSWORD_FIELD] {password_field}\n")
                        file.write(f"[RESPONSE_STRING] {response_string}\n")
     
                # Ensure variables are defined before replacing in command
                if request_header and username_field and password_field and response_string:
                    if "[REQUEST_HEADER]" in command:
                        command = command.replace("[REQUEST_HEADER]", request_header)
                    if "[USERNAME_FIELD]" in command:
                        command = command.replace("[USERNAME_FIELD]", username_field)
                    if "[PASSWORD_FIELD]" in command:
                        command = command.replace("[PASSWORD_FIELD]", password_field)
                    if "[RESPONSE_STRING]" in command:
                        command = command.replace("[RESPONSE_STRING]", response_string)
                        
            elif check_name == "sqlmap-sql-db-scan":
                self.sqlmap_default()
                                      
            elif check_name == "sqlmap-sql-table-dump":
                if "[DATABASES]" in command:
                    databases = input("\033[1m[>] Enter the database name to dump (e.g., db2): \033[0m")
                    print("")
                    command = command.replace("[DATABASES]", databases)
                
                self.sqlmap_default()
                
            elif check_name == "sqlmap-sql-column-dump":
                if "[DATABASES]" in command:
                    databases = input("\033[1m[>] Enter the database name to dump (e.g., db2): \033[0m")
                    command = command.replace("[DATABASES]", databases)
                
                if "[TABLES]" in command:
                    tables = input("\033[1m[>] Enter the table name to dump (e.g., users): \033[0m")
                    print("")
                    command = command.replace("[TABLES]", tables)
                    
                self.sqlmap_default()
                
        except Exception as e:
            logger.error(f"Error: {e}")
            
        finally:
            return command
    #-----------------------------------------------------------------------
    
    def burp_suite_open(self, sqlmap_request_file):
        subprocess.run(["burpsuite"])
    
        if os.path.exists(sqlmap_request_file):  
            with open(sqlmap_request_file, "r") as file:
                sql_request = file.read()
                
            if sql_request:
                sql_request = sql_request
        return sql_request
                
    #-----------------------------------------------------------------------
    
    def sqlmap_default(self):
        """
        Run the default SQLMap command.
        """
        sql_request = None
        
        # Check if sqlmap_request.txt exists
        sqlmap_request_file = os.path.join(RESULTS_DIR, "sqlmap-sql-injection-request.txt")
        
        if not os.path.exists(sqlmap_request_file):
            with open(sqlmap_request_file, "w") as file:
                # create the file if it does not exist
                file.write("")
        
        burpsuite_decision = input(f"\033[1m[>] Would you like to launch Burpsuite to get the request? (Y/n): \033[0m")
        if burpsuite_decision.lower() == 'y':
            sql_request = self.burp_suite_open(sqlmap_request_file)
            print("")
            
        else:
            print("")
            import_decision = "n"
            
            if os.path.exists(sqlmap_request_file):
                # First, display the previous request
                with open(sqlmap_request_file, "r") as file:
                    sql_request = file.read()
                
                if sql_request:
                    Output.print(f"+------------------------+", color="blue", attrs="bold")
                    Output.print(f"[*] Previous request found:", color="blue", attrs="bold")
                    Output.print(f"+------------------------+", color="blue", attrs="bold")
                    Output.print(f"{sql_request}", color="green")
                    Output.print(f"+------------------------+", color="blue", attrs="bold")
                    print("")
                    
                    # Then ask if the user wants to import it
                    import_decision = input(f"\033[1m[>] Would you like to import the previous request? (Y/n): \033[0m")
                    print("")
                    if import_decision.lower() == 'y':
                        import_decision = 'y'
                        sql_request = sql_request  
            
        # Prompt for inputs if not importing or no previous inputs
        if not sql_request and import_decision.lower() == 'n':
            logger.info("Request for the SQL injection not found.")
            logger.error("Please provide the request for the SQL injection.")    
            
            burpsuite_decision = input(f"\033[1m[>] Launch Burpsuite to get the request or import from the request file? (Y/n): \033[0m")
            print("")
            
            if burpsuite_decision.lower() == 'y':
                self.burp_suite_open(sqlmap_request_file)
            else:
                if os.path.exists(sqlmap_request_file):
                    # First, display the previous request
                    with open(sqlmap_request_file, "r") as file:
                        sql_request = file.read()
                        
                    if sql_request:
                        logger.info("Request will be imported from the request file.")
                        print("")
                        return None
                    else:
                        logger.error("Request file is empty.")